# Exercise 1: Writing your first OAS Document

In this exercise, you will learn what Swagger/OpenAPI is and how you can leverage the specification to to design your APIs from scratch. You will start by analyzing a simple use case and you'll use it to define (roughly) how you want our API to be. Then, you'll move to a web-based tool that not only will help us to write the API definition, but will also give us a lot of goodies for free that will allow our consumers to understand and test our API even if the real implementation does not exist. Finally, you will talk about the next steps of the API creation lifecycle and how you can use what you did to speed up the entire process.

But before going further, we need to address the elephant in the room, **what is Swagger, OpenAPI and OAS?**

## What is Swagger/OpenAPI/OAS

Swagger is an open source software framework backed by a broad ecosystem of tools that helps developers design, build, document, standardize and consume [RESTful Web services](https://en.wikipedia.org/wiki/Representational_state_transfer). While most users identify Swagger by the Swagger UI tool, the Swagger toolset includes support for automated documentation, code generation, and test case generation.

![Swagger Logo](./assets/swagger-logo.png)

In November 2015, the [Open API Initiative](https://www.openapis.org/) was created with the sponsorship of the Linux Foundation with the goal of standardizing how to describe REST APIs. A variety of companies, including Google, IBM, Microsoft, and MuleSoft are current members of this Collaborative Project. On January 2016 **the Swagger specification was renamed to OpenAPI Specification**, and was moved to a new repository in GitHub. While the specification itself was not changed, this renaming signified the split between the API description format and the open source tooling. As of July 2017, Swagger tools are downloaded over 100,000 times per day, according to hosting repositories Sonatype and NPM.

![OpenAPI initiative](./assets/open-api-initiative.png)

> **Note:** The specification, as well as other information, is stored in GitHub. The current active version of the spec is **3.0.2**, but for this workshop **we are going to use OpenAPI 2.0** because the tools we'll use were not yet updated to v3. You can find the full documentation of the specs here:
>
> - [OpenAPI 2.0 specs](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) (the version you are going to use in this workshop)
> - [OpenAPI 3.0 specs](https://github.com/OAI/OpenAPI-Specification) (the current active version)

## The scenario

We were asked by the NodeConf organizers to create an API for the conference this year, that might potentially be used by all NodeConf conferences in the world. The team is composed by a backend team and a front end team, and all members are scattered across the globe. The NodeConf organizers also want to make everything open source and well documented, allowing any developer to help the team with both the implementation and the definition of the API.

The use cases that we need to support in this initial version are:

- Retrieve the list of Speakers of an specific conference.
- Retrieve the list of Activities of an specific conference, that may have one or more Speakers.
- Retrieve the Agenda of the current conference, composed by one or more activities.
- Finally, add the ability to provide feedback to each activity.

## Steps

### Create your first OAS document in SwaggerHub

SwaggerHub is the official design tool for Swagger documents that help you to write APIs according to specification-based standards. This open source tool provides a lot of features in its free tier that you are going to use throughout this workshop:

- A web-based editor with autocomplete capabilities that will guide you in the process of defining your API.
- Real-time autogenerated API documentation that will help others to understand what your API does.
- An API Mocking service that will simulate the responses of a real service implementing your API definition.

![SwaggerHub](./assets/swaggerhub.png)

> **Note:** In addition to the free tier, SwaggerHub offers two more subscriptions that provide extra capabilities more suited for teams and enterprises, like collaboration, source control sync, domain management, customer support, etc. You can find more info about this [here](https://swagger.io/tools/swaggerhub/pricing/).

In this section, you are going to use SwaggerHub to create the skeleton of your first Swagger/OAS document in your own personal account.

1. Open a new browser tab and navigate to the Swagger's online editor, [SwaggerHub](https://app.swaggerhub.com/).
1. Use the buttons at the top right to either create a new account associated with your GitHub profile or log in to an existing account.

![Sign in to SwaggerHub](./assets/swaggerhub-signin.png)

1. After logging/signing in, you will be redirected to **Your hub** page. In the left panel, click the **Create New** button and select **Create new API**.

![Create new API](swaggerhub-create-new-api.png)

1. The **Select a Template or create a Blank API** modal will appear. Enter the following information and then click **Create API**.

   - OpenAPI version: `2.0`
   - Template: `-- None --`
   - Name: `nodeconf-api`
   - Version: `1.0.0`
   - Title: `NodeConf API`
   - Description: `This is the API for the NodeConf`
   - Visibility: `Private`
   - Auto Mock API: `ON`
   - Owner: <your-user>.

   ![Create API modal form](./assets/swaggerhub-create-new-api-form.png)

   > **Note:** _Why Swagger 2.0?_ The current active version of the OpenAPI spec is **3.0.2**, but for this workshop **we are going to use OpenAPI 2.0** because the tools we'll use were not yet updated to v3.

SwaggerHub will now use the information you filled in to create the initial the skeleton of your API definition, and then it will redirect you to the **Design View** of your newly created API definition (or OpenAPI document, both terms are equivalent).

![Your first OAS document in SwaggerHub](./assets/swaggerhub-api-skeleton.png)

This private and unpublished API description contains the Swagger version and other basic information of your API. In addition, there is other stuff autogenerated by the Auto Mocking Plugin (you'll see what this is later in the exercise).

Finally, notice that the `paths` property has an empty object (`{}`). In the next sections, we are going to replace this object with some real paths.

## Implement your first OAS document

In the initial section of this exercise, we described the initial use cases we have to support. Let's do a quick recap:

- Retrieve the list of Speakers of an specific conference.
- Retrieve the list of Activities of an specific conference, that may have one or more Speakers.
- Retrieve the Agenda of the current conference, composed by one or more activities.
- Finally, add the ability to provide feedback to each activity.

As you could have figured out yet, these use cases define some clear entities your consumers will have to interact with, like _Speaker_, _Activities_ and _Agenda_. And some actions your API need to support for this, like retrieving these entities or sending new _Feedback_. We can model all of these interactions by using a [REST architecture](https://en.wikipedia.org/wiki/Representational_state_transfer) for our API. Using it, we can start defining some key aspects of our API:

- It needs a path that accepts a **GET** action to return a collection of **Speakers** in a **JSON** format, along with a **200** status code.
- Similarly, it needs a path to retrieve **Activities** and a path to retrieve the **Agenda**.
- If you want to use this API for more than just a conference, users need to be able to identify the conference they are targetting to. There are several ways to do this, being the most common the inclusion of the conference ID as part of all paths. For simplicity, you would use the year of the conference as its ID. And you will use **edition** to allow any type of event, not only conferences.
- Last, it needs a path to receive **Feedback** of activities. This path should allow **POST** actions containing information in the body with the user's opinion.

> **Note:** if you haven't heard about REST or you are still getting familiarized with it, we recommend you to read [this](https://www.restapitutorial.com/) tutorial.

With these ideas in mind, let's start updating our OAS document:

### Retrieve the list of Speakers

1. First, you are going to add the **path** to retrieve the speakers of the conference. It will consist on a path to the speakers resources and will contain a template (curly braces) with the _editionId_ parameter. Replace the empty object in the `paths` key with the following:

   ```
   paths:
      /editions/{editionId}/speakers:
   ```

   > **Note:** Path templating refers to the usage of curly braces ({}) to mark a section of a URL path as replaceable using path _parameters_. In this case, users will call to `/editions/2018/speakers` to get the Speakers collection of the year 2018.

1. Next, you need to define the shape of the **parameter** we are going to use in this path. Since we are going to use a **path** parameter, we need to define its _name_, which must correspond to the associated path segment in the path field, its type and if its required or not. Paste the following code below the path you've just added in your API document:

   ```
   paths:
     /editions/{editionId}/speakers:
       parameters:
       - name: editionId
         in: path
         description: Year of the hosted edition
         required: true
         type: string
   ```

   > **Note:** you can define parameters in your _path_, _query_, _body_ and _formData_. You can learn how to configure all of them by navigating [here](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameter-object).

1. Now you need to add the actual **operation** that will be used to retrieve the Speakers, as all paths support many (REST) operations. Below the _parameter_ definition, add a **GET** operation with a summary explaining what it does, as shown in the code snippet below:

   ```
   paths:
     /editions/{editionId}/speakers:
       parameters:
         ...
       get:
         summary: Retrieves the speakers
   ```

> **Note:** If you want to learn more about _operations_ and their configurations, see [here](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject).

1. Define the available response formats of this operation by adding [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types) in the **produces** array. The scenario defines that the API only needs to support `application/json`; let's add only this value for now:

   ```
   paths:
     /editions/{editionId}/speakers:
       parameters:
         ...
       get:
         summary: Retrieves the speakers
         produces:
           - application/json
   ```

1. Next, define the different responses this operation can retrieve. [REST defines several response types](https://restfulapi.net/http-status-codes/), identifying each one of them with a **status code**. You should define all possible responses your operation could return, but to fullfill the requirements of this exercise only define a single **200 (OK)** response type in this operation. Don't forget to add a description explaining what it does:

   ```
   paths:
     /editions/{editionId}/speakers:
       parameters:
         ...
       get:
         summary: Retrieves the speakers
       responses:
         200:
           description: A list of speakers of the edition
   ```

   > **Note:** You can find more information about the **responses** object [here](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#responses-object).

1. Every response has a structure, it can be a primitive, an array, an object or even an empty value. Swagger/OAS use the **schema** property to define the structure of the response. You could define these structures inline, but this will make our API document harder to read, as these responses are usually complex. Instead, you can also use the **$ref** property to reference to any internal or external section of an Swagger/OAS document.

   Take advantage of this feature in Swagger to reduce the amount of information in the paths. Since we need to retrieve a collection of speakers, add a `type: array` property inside the **schema** object. Then, use the **items** property to define the type of the entities the API is going to return, but use `$ref: '#/definitions/Speaker'`. Your API definition should look like the following:

   ```
   paths:
     /editions/{editionId}/speakers:
       parameters:
         ...
       get:
         summary: Retrieves the speakers
         responses:
           200:
             description: all speakers of the edition
             schema:
               type: array
               items:
                 $ref: '#/definitions/Speaker'
   ```

   > **Note:** Learn more about the Reference object [here](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#reference-object).

1. SwaggerHub will complain about the missing _Speaker_ definition in your API document. What you need to do next is to add a new **definitions** property in the root of your document containing the definition of the _Speaker_ object, with the following properties: _id_, _name_, _description_, _imageUrl_, _githubAccount_ and _twitterAccount_:

   ```
   swagger: '2.0'
   info:
     ...

   paths:
     ...

   definitions:
     Speaker:
       type: object
       required:
         - id
         - name
         - description
         - imageUrl
         - githubAccount
         - twitterAccount
       properties:
         id:
           type: string
           format: uuid
           example: d290f1ee-6c54-4b01-90e6-d701748f0851
         name:
           type: string
           example: John Doe
         description:
           type: string
           example: Node JS Developer
         imageUrl:
           type: string
           format: uri
           example: http://some.image.com/image.png
         githubAccount:
           type: string
           example: '@i-am-a-developer'
         twitterAccount:
           type: string
           example: '@john-doe'
   ```

   > **Note:** inside the _definition_ you can add any data type that follows the [Schema Object specification](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schemaObject).

1. If everything is OK, you should see no error in SwaggerHub. What's more, you should see the following sections in your browser:

   - In the left panel, the list of available _Paths_ and the _Models_ defined in your API document.
   - At the top of the right panel, the description of your API.
   - At the bottom of the right panel, detailed description of the _Paths_ and the **Try it out** button.

   ![SwaggerHub Speakers endpoint](./assets/swaggerhub-speakers-endpoint.png)

1. Finally, click **Save** and let's test your newly created endpoint.

#### Test the endpoint

Even with a basic definition of the endpoint, you can use the **Try it out!** functionality to test how it would behave and/or get early feedback of your design before it is implemented. This functionality leverages the **API Auto mocking** integration in your API (the autogenerated code at the bottom) to return a response mock based on the examples you defined in your API document.

It is even useful to allow developers to start building client applications even before the API back end is ready.

> **Note:** You can learn more about the _API Auto mocking_ integration [here](https://app.swaggerhub.com/help/integrations/api-auto-mocking).

1. In the right panel of your API, click the **/editions/{editionId}/speakers** row to expand it.
1. Now, click the **Try it out** button. Notice that a field will appear below _Year of the hosted edition_.
1. In this new field, enter any value for the **editionId**. For instance, use `2018`.
1. Finally, click the **Execute** button.
1. Scroll down to visualize the output. You will see a section containing the cURL, the request URL that was made and the server response. Notice that this value is similar to the example you've set for this path.

   ![Speakers try it out](./assets/speakers-try-it-out.png)

### Retrieve the list of Activities

TODO - Do the same thing with the other endpoints **/editions/{editionId}/agenda:**

#### Test the endpoint

TBC

### Retrieve the Agenda

TODO - Do the same thing with the other endpoints **/editions/{editionId}/activities:**

#### Test the endpoint

TBC

### Provide feedback to an Activity

TODO - Do the same thing with the other endpoints **/editions/{editionId}/feedback:**

#### Test the endpoint

TBC

## Leverage Swagger capabilities to improve your OAS document

1. Reuse parameters by redefining a type (editionId)

- Define a new **parameters** section at the bottom, with an property `editionId` inside with the information previously defined

```
parameters:
  editionId:
    name: editionId
    in: path
    description: Year of the hosted edition
    required: true
    type: integer
```

- For all the endpoints we've previously created, remove the harcoded parameter and change it for a reference to the **editionId** parameter. For example:

```
paths:
  /editions/{editionId}/speakers:
    parameters:
      - $ref: '#/parameters/editionId'
```

1. Improve query by using an enum (event types). Explain that swagger 3.0 has a better way.

When using query parameters that have defined codes, you can specify an enum on the property of the parameter to only accept those codes as possible.

Let's use this on the example of the agenda, where users could filter on activity type. Types could be: [talk, lightning-talk, workshop, coffee-break]

```
...
    get:
      summary: Searches events on the agenda
      description: Can search for all events on the agenda, or filter by type
      parameters:
        - in: query
          name: type
          description: pass an optional type to filter the events
          required: false
          type: string
          enum: [talk, lightning-talk, workshop, coffee-break]
```

1. Define default response with ErrorResponse object

You can specify a default response. For this add to the endpoints on the **responses** property the following:

```
      responses:
        200:
          description: all speakers of the edition
          schema:
            type: array
            items:
              $ref: '#/definitions/Speaker'
        default:
          $ref: '#/definitions/ErrorResponse'
```

As you can see, it is using an **ErrorResponse** definition not yet placed in the doc. Add it on the **definitions** section:

```
definitions:
  Speaker:
    ...

  ErrorResponse:
    description: Response containing an error
    type: object
    properties:
      errorMessage:
        type: string
```

## Test your newly created API

1. Download Postman Collection and start hitting the API (mocking service)

- Locate the export drop-down at the top-right corner of the screen, and click on it
- Select **Download API**
- Select **JSON Resolved**
- This will download a **zip** file that you'll need to decompress.
- Open **Postman**
- Click on **Import**
- On the **Import File** tab click on **Choose Files**
- Locate and select the **.json** that was inside the generated zip file
- A new collection will be added with all the requests our API currently has
- Select any request, add an **editionId** to the request, and play with it.
- You'll see that the responses are the same as when using the **Try it out!** feature, and this is because we are using the mocking server provided by Swagger Hub for you API.
