# Exercise 1: Writing your First API Specification

In this exercise, you will

## Introduction

- What is swagger
- Define use case: Build NodeConf App (explain it)
- Define workforce: 2 different teams, one backend & one frontend (us)
- Output: OAS Document (API Spec), which is a definition of our API

### What is Swagger/OpenAPI/OAS

Swagger is an open source software framework backed by a broad ecosystem of tools that helps developers design, build, document, standardize and consume [RESTful Web services](https://en.wikipedia.org/wiki/Representational_state_transfer). While most users identify Swagger by the Swagger UI tool, the Swagger toolset includes support for automated documentation, code generation, and test case generation.

![Swagger Logo](./assets/swagger-logo.png)

In November 2015, the [Open API Initiative](https://www.openapis.org/) was created with the sponsorship of the Linux Foundation with the goal of standardizing how to describe REST APIs. A variety of companies, including Google, IBM, Microsoft, and MuleSoft are current members of this Collaborative Project. On January 2016 **the Swagger specification was renamed to OpenAPI Specification**, and was moved to a new repository in GitHub. While the specification itself was not changed, this renaming signified the split between the API description format and the open source tooling. As of July 2017, Swagger tools are downloaded over 100,000 times per day, according to hosting repositories Sonatype and NPM.

![OpenAPI initiative](./assets/open-api-initiative.png)

> **Note:** The specification, as well as other information, is stored in GitHub. The current active version of the spec is **3.0.2**, but for this workshop, **we are going to focus OpenAPI 2.0**, mainly because the tools were not yet updated to v3. You can find the full documentation of the specs here:
>
> - [OpenAPI 2.0 specs](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) (the version we are going to use in this workshop)
> - [OpenAPI 3.0 specs](https://github.com/OAI/OpenAPI-Specification) (the current active version)

## Use SwaggerHub to create an OAS document

SwaggerHub is the official design tool for Swagger documents that help you to write APIs according to specification-based standards. This open source tool provides a lot of features in its free tier that you are going to use throughout this workshop:

- A web-based editor with autocomplete capabilities that will guide you in the process of defining your API.
- Real-time autogenerated API documentation that will help others to understand what your API does.
- An API Mocking service that will simulate the responses of a real service implementing your API definition.

![SwaggerHub](./assets/swaggerhub.png)

> **Note:** In addition to the free tier, SwaggerHub offers two more subscriptions that provide extra capabilities more suited for teams and enterprises, like collaboration, source control sync, domain management, customer support, etc. You can find more info about this [here](https://swagger.io/tools/swaggerhub/pricing/).

### Create your first OAS document in SwaggerHub

In this section, you are going to sign in into SwaggerHub with your personal account and then you are going to create the skeleton of your first Swagger/OAS document.

1. Open a new browser tab and navigate to the Swagger's Online Editor, [SwaggerHub](https://app.swaggerhub.com/).
1. Create a new account associated with your GitHub profile or log in to your account.

![Sign in to SwaggerHub]()

1. In the left panel, click the **Create New** button and select **Create new API**.

![Create new API]()

1. In the **Select a Template or create a Blank API** popup, enter the following info and then click **Create API**.

   - OpenAPI version: `2.0`
   - Template: `-- None --`
   - Name: `nodeconf-api`
   - Version: `1.0.0`
   - Title: `NodeConf API`
   - Description: `This is the API for the NodeConf`
   - Visibility: `Private`
   - Auto Mock API: `ON`
   - Owner: <your-user>.

   ![Create API modal info]()

   > **Note:** Why Swagger 2.0

After the API is created, you will be redirected to your new OAS document. Some information will be filled in for you, like the swagger version, the information of the API (version, title and description), an empty paths field and some other stuff autogenerated by the Auto Mocking Plugin (we'll see what this is later in the exercise).

![Your first OAS document in SwaggerHub]()

### Implement your first OAS document

- Lets identify objects (Speakers, Workshops, etc)

Now it's time to implement our first document using the OAS/Swagger specification. We need to:

- Retrieve the list of Speakers of an specific conference.
- Retrieve the list of Activities of an specific conference, that may have one or more Speakers.
- Retrieve the Agenda of the current conference, composed by one or more activities.
- Finally, add the ability to provide feedback to the Activities.

Let's start

We are going to add the endpoint to retrieve the speakers of the conference.

For this, first we are going to modify the **paths** object from:

```
paths: {}
```

to:

```
paths:
  /editions/{editionId}/speakers:
```

Now that we've added this endpoint, we need to define a couple of things:

- Define a new parameter for the endpoint:

```
paths:
  /editions/{editionId}/speakers:
    parameters:
    - name: editionId
      in: path
      description: Year of the hosted edition
      required: true
      type: string
```

[TODO - NOTE EXPLAINING WHAT A PARAMETER IS]

- Now, add a new action for the endpoint. This will be a **GET** action:

```
paths:
  /editions/{editionId}/speakers:
    parameters:
      - $ref: '#/parameters/editionId'

    get:
```

- Add a summary for the action.

- Include what kind of format the response will produce. In this case, it will be a json

- Define the responses of the endpoint. Let's add a **200** as a first expected response

- You can provide more information to the response by adding a description

- You can also detail the schema of the object to return when the endpoint is called.

  - First you need to create a new definition. In this case you'll create the definition of a **Speaker** at the bottom of the Doc. A Speaker will have the following properties: [id, name, description, imageUrl, githubAccount, twitterAccount]

```
definitions:
  Speaker:
    type: object
    required:
      - id
      - name
      - description
      - imageUrl
      - githubAccount
      - twitterAccount
    properties:
      id:
        type: string
        format: uuid
        example: d290f1ee-6c54-4b01-90e6-d701748f0851
      name:
        type: string
        example: John Doe
      description:
        type: string
        example: Node JS Developer
      imageUrl:
        type: string
        format: uri
        example: http://some.image.com/image.png
      githubAccount:
        type: string
        example: '@i-am-a-developer'
      twitterAccount:
        type: string
        example: '@john-doe'
```

[TODO - ADD SCREENSHOT WITH MODEL CREATED AT LEFT PANEL]

- And finally you'll need to reference this definition on the schema of the endpoint:

```
    get:
      summary: retrieves the speakers
      produces:
        - application/json
      responses:
        200:
          description: all speakers of the edition
          schema:
            type: array
            items:
              $ref: '#/definitions/Speaker'
```

- Now, click save

Let's try this out!

With this basic definition of the endpoint, we can use the **Try it out!** functionality to test how it would behave.

- Using the right panel, look for the new speakers endpoint created, and click on it
- Select the **Try it out** option
- Place an **editionId** number, for example 2018
- And finally click on **Execute**
- Scroll down and see what the output was. As you can see, that information was previously populated by you when defining the schema of the speaker.

```
[
  {
    "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
    "name": "John Doe",
    "description": "Node JS Developer",
    "imageUrl": "http://some.image.com/image.png",
    "githubAccount": "@i-am-a-developer",
    "twitterAccount": "@john-doe"
  }
]
```

[TODO - EXPLAIN WHY THIS WORKS AND WHAT IS A MOCKING SERVICE]

TODO - Do the same thing with the other endpoints **/editions/{editionId}/agenda:**
TODO - Do the same thing with the other endpoints **/editions/{editionId}/activities:**
TODO - Do the same thing with the other endpoints **/editions/{editionId}/feedback:**

## Leverage Swagger capabilities to improve your OAS document

1. Reuse parameters by redefining a type (editionId)

- Define a new **parameters** section at the bottom, with an property `editionId` inside with the information previously defined

```
parameters:
  editionId:
    name: editionId
    in: path
    description: Year of the hosted edition
    required: true
    type: integer
```

- For all the endpoints we've previously created, remove the harcoded parameter and change it for a reference to the **editionId** parameter. For example:

```
paths:
  /editions/{editionId}/speakers:
    parameters:
      - $ref: '#/parameters/editionId'
```

1. Improve query by using an enum (event types). Explain that swagger 3.0 has a better way.

When using query parameters that have defined codes, you can specify an enum on the property of the parameter to only accept those codes as possible.

Let's use this on the example of the agenda, where users could filter on activity type. Types could be: [talk, lightning-talk, workshop, coffee-break]

```
...
    get:
      summary: Searches events on the agenda
      description: Can search for all events on the agenda, or filter by type
      parameters:
        - in: query
          name: type
          description: pass an optional type to filter the events
          required: false
          type: string
          enum: [talk, lightning-talk, workshop, coffee-break]
```

1. Define default response with ErrorResponse object

You can specify a default response. For this add to the endpoints on the **responses** property the following:

```
      responses:
        200:
          description: all speakers of the edition
          schema:
            type: array
            items:
              $ref: '#/definitions/Speaker'
        default:
          $ref: '#/definitions/ErrorResponse'
```

As you can see, it is using an **ErrorResponse** definition not yet placed in the doc. Add it on the **definitions** section:

```
definitions:
  Speaker:
    ...

  ErrorResponse:
    description: Response containing an error
    type: object
    properties:
      errorMessage:
        type: string
```

## Test your newly created API

1. Download Postman Collection and start hitting the API (mocking service)

- Locate the export drop-down at the top-right corner of the screen, and click on it
- Select **Download API**
- Select **JSON Resolved**
- This will download a **zip** file that you'll need to decompress.
- Open **Postman**
- Click on **Import**
- On the **Import File** tab click on **Choose Files**
- Locate and select the **.json** that was inside the generated zip file
- A new collection will be added with all the requests our API currently has
- Select any request, add an **editionId** to the request, and play with it.
- You'll see that the responses are the same as when using the **Try it out!** feature, and this is because we are using the mocking server provided by Swagger Hub for you API.

## Bonus track

1. Add POST, PATCH and PUT (here).
1. Push OAS document (API spec) in GitHub’s backend repo.
